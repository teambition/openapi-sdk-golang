/*
Teambition Open API

Teambition Open API

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// FileAPIService FileAPI service
type FileAPIService service

type ApiBatchGetFileDetailsRequest struct {
	ctx context.Context
	ApiService *FileAPIService
	xOperatorId *string
	xTenantId *string
	batchGetFileDetailsRequest *BatchGetFileDetailsRequest
}

// 操作者ID
func (r ApiBatchGetFileDetailsRequest) XOperatorId(xOperatorId string) ApiBatchGetFileDetailsRequest {
	r.xOperatorId = &xOperatorId
	return r
}

// 企业 ID
func (r ApiBatchGetFileDetailsRequest) XTenantId(xTenantId string) ApiBatchGetFileDetailsRequest {
	r.xTenantId = &xTenantId
	return r
}

// 
func (r ApiBatchGetFileDetailsRequest) BatchGetFileDetailsRequest(batchGetFileDetailsRequest BatchGetFileDetailsRequest) ApiBatchGetFileDetailsRequest {
	r.batchGetFileDetailsRequest = &batchGetFileDetailsRequest
	return r
}

func (r ApiBatchGetFileDetailsRequest) Execute() (*BatchGetFileDetailsResponse, *http.Response, error) {
	return r.ApiService.BatchGetFileDetailsExecute(r)
}

/*
BatchGetFileDetails 根据 resourceId 批量获取文件详情

根据 resourceId 批量获取文件详情

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchGetFileDetailsRequest

  @link https://open.teambition.com/docs/apis/65b20e66912d20d3b5781196 document
*/
func (a *FileAPIService) BatchGetFileDetails(ctx context.Context) ApiBatchGetFileDetailsRequest {
	return ApiBatchGetFileDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BatchGetFileDetailsResponse
func (a *FileAPIService) BatchGetFileDetailsExecute(r ApiBatchGetFileDetailsRequest) (*BatchGetFileDetailsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchGetFileDetailsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/file/query/by-resource-ids"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xOperatorId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-operator-id", r.xOperatorId, "")
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	// body params
	localVarPostBody = r.batchGetFileDetailsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateFileV3Request struct {
	ctx context.Context
	ApiService *FileAPIService
	xOperatorId *string
	xTenantId *string
	createFileV3Request *CreateFileV3Request
}

// 操作者ID
func (r ApiCreateFileV3Request) XOperatorId(xOperatorId string) ApiCreateFileV3Request {
	r.xOperatorId = &xOperatorId
	return r
}

// 企业 ID
func (r ApiCreateFileV3Request) XTenantId(xTenantId string) ApiCreateFileV3Request {
	r.xTenantId = &xTenantId
	return r
}

// 
func (r ApiCreateFileV3Request) CreateFileV3Request(createFileV3Request CreateFileV3Request) ApiCreateFileV3Request {
	r.createFileV3Request = &createFileV3Request
	return r
}

func (r ApiCreateFileV3Request) Execute() (*CreateFileV3Response, *http.Response, error) {
	return r.ApiService.CreateFileV3Execute(r)
}

/*
CreateFileV3 创建文件库文件

创建文件库文件

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateFileV3Request

  @link https://open.teambition.com/docs/apis/6411504e912d20d3b56ec570 document
*/
func (a *FileAPIService) CreateFileV3(ctx context.Context) ApiCreateFileV3Request {
	return ApiCreateFileV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateFileV3Response
func (a *FileAPIService) CreateFileV3Execute(r ApiCreateFileV3Request) (*CreateFileV3Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateFileV3Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/work/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xOperatorId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-operator-id", r.xOperatorId, "")
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	// body params
	localVarPostBody = r.createFileV3Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateFolderV3Request struct {
	ctx context.Context
	ApiService *FileAPIService
	xOperatorId *string
	xTenantId *string
	createFolderV3Request *CreateFolderV3Request
}

// 操作者ID
func (r ApiCreateFolderV3Request) XOperatorId(xOperatorId string) ApiCreateFolderV3Request {
	r.xOperatorId = &xOperatorId
	return r
}

// 企业 ID
func (r ApiCreateFolderV3Request) XTenantId(xTenantId string) ApiCreateFolderV3Request {
	r.xTenantId = &xTenantId
	return r
}

// 
func (r ApiCreateFolderV3Request) CreateFolderV3Request(createFolderV3Request CreateFolderV3Request) ApiCreateFolderV3Request {
	r.createFolderV3Request = &createFolderV3Request
	return r
}

func (r ApiCreateFolderV3Request) Execute() (*CreateFolderV3Response, *http.Response, error) {
	return r.ApiService.CreateFolderV3Execute(r)
}

/*
CreateFolderV3 创建文件夹

创建文件夹

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateFolderV3Request

  @link https://open.teambition.com/docs/apis/64db2903912d20d3b5bb0034 document
*/
func (a *FileAPIService) CreateFolderV3(ctx context.Context) ApiCreateFolderV3Request {
	return ApiCreateFolderV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateFolderV3Response
func (a *FileAPIService) CreateFolderV3Execute(r ApiCreateFolderV3Request) (*CreateFolderV3Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateFolderV3Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/collection/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xOperatorId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-operator-id", r.xOperatorId, "")
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	// body params
	localVarPostBody = r.createFolderV3Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateUploadTokenV3Request struct {
	ctx context.Context
	ApiService *FileAPIService
	xOperatorId *string
	xTenantId *string
	createUploadTokenV3Request *CreateUploadTokenV3Request
}

// 操作者ID
func (r ApiCreateUploadTokenV3Request) XOperatorId(xOperatorId string) ApiCreateUploadTokenV3Request {
	r.xOperatorId = &xOperatorId
	return r
}

// 企业 ID
func (r ApiCreateUploadTokenV3Request) XTenantId(xTenantId string) ApiCreateUploadTokenV3Request {
	r.xTenantId = &xTenantId
	return r
}

// 
func (r ApiCreateUploadTokenV3Request) CreateUploadTokenV3Request(createUploadTokenV3Request CreateUploadTokenV3Request) ApiCreateUploadTokenV3Request {
	r.createUploadTokenV3Request = &createUploadTokenV3Request
	return r
}

func (r ApiCreateUploadTokenV3Request) Execute() (*CreateUploadTokenV3Response, *http.Response, error) {
	return r.ApiService.CreateUploadTokenV3Execute(r)
}

/*
CreateUploadTokenV3 创建文件上传凭证

创建文件上传凭证

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateUploadTokenV3Request

  @link https://open.teambition.com/docs/apis/64114f70912d20d3b56e0c59 document
*/
func (a *FileAPIService) CreateUploadTokenV3(ctx context.Context) ApiCreateUploadTokenV3Request {
	return ApiCreateUploadTokenV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateUploadTokenV3Response
func (a *FileAPIService) CreateUploadTokenV3Execute(r ApiCreateUploadTokenV3Request) (*CreateUploadTokenV3Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateUploadTokenV3Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/awos/upload-token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xOperatorId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-operator-id", r.xOperatorId, "")
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	// body params
	localVarPostBody = r.createUploadTokenV3Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFileDetailV3Request struct {
	ctx context.Context
	ApiService *FileAPIService
	xOperatorId *string
	xTenantId *string
	workIds *string
	needSign *bool
}

// 操作者ID
func (r ApiGetFileDetailV3Request) XOperatorId(xOperatorId string) ApiGetFileDetailV3Request {
	r.xOperatorId = &xOperatorId
	return r
}

// 企业 ID
func (r ApiGetFileDetailV3Request) XTenantId(xTenantId string) ApiGetFileDetailV3Request {
	r.xTenantId = &xTenantId
	return r
}

// 项目文件 ID 集合，使用逗号分隔，最多查询500个
func (r ApiGetFileDetailV3Request) WorkIds(workIds string) ApiGetFileDetailV3Request {
	r.workIds = &workIds
	return r
}

// 是否获取文件下载链接，默认false（仅支持付费企业）
func (r ApiGetFileDetailV3Request) NeedSign(needSign bool) ApiGetFileDetailV3Request {
	r.needSign = &needSign
	return r
}

func (r ApiGetFileDetailV3Request) Execute() (*GetFileDetailV3Response, *http.Response, error) {
	return r.ApiService.GetFileDetailV3Execute(r)
}

/*
GetFileDetailV3 获取项目文件详情

获取项目文件详情

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFileDetailV3Request

  @link https://open.teambition.com/docs/apis/64db2921912d20d3b5bb5250 document
*/
func (a *FileAPIService) GetFileDetailV3(ctx context.Context) ApiGetFileDetailV3Request {
	return ApiGetFileDetailV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetFileDetailV3Response
func (a *FileAPIService) GetFileDetailV3Execute(r ApiGetFileDetailV3Request) (*GetFileDetailV3Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetFileDetailV3Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/work/query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.workIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "workIds", r.workIds, "")
	}
	if r.needSign != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "needSign", r.needSign, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xOperatorId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-operator-id", r.xOperatorId, "")
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFileTokenRequest struct {
	ctx context.Context
	ApiService *FileAPIService
	xTenantId *string
	getFileTokenRequest *GetFileTokenRequest
}

// 企业 ID
func (r ApiGetFileTokenRequest) XTenantId(xTenantId string) ApiGetFileTokenRequest {
	r.xTenantId = &xTenantId
	return r
}

// 
func (r ApiGetFileTokenRequest) GetFileTokenRequest(getFileTokenRequest GetFileTokenRequest) ApiGetFileTokenRequest {
	r.getFileTokenRequest = &getFileTokenRequest
	return r
}

func (r ApiGetFileTokenRequest) Execute() (*GetFileTokenResponse, *http.Response, error) {
	return r.ApiService.GetFileTokenExecute(r)
}

/*
GetFileToken 从现有文件资源创建 fileToken，可用于创建其他文件资源

从现有文件资源创建 fileToken，可用于创建其他文件资源

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFileTokenRequest

  @link https://open.teambition.com/docs/apis/65810e45912d20d3b5887d1b document
*/
func (a *FileAPIService) GetFileToken(ctx context.Context) ApiGetFileTokenRequest {
	return ApiGetFileTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetFileTokenResponse
func (a *FileAPIService) GetFileTokenExecute(r ApiGetFileTokenRequest) (*GetFileTokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetFileTokenResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/file/file-token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	// body params
	localVarPostBody = r.getFileTokenRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFolderDetailV3Request struct {
	ctx context.Context
	ApiService *FileAPIService
	xOperatorId *string
	xTenantId *string
	collectionIds *string
}

// 操作者ID
func (r ApiGetFolderDetailV3Request) XOperatorId(xOperatorId string) ApiGetFolderDetailV3Request {
	r.xOperatorId = &xOperatorId
	return r
}

// 企业 ID
func (r ApiGetFolderDetailV3Request) XTenantId(xTenantId string) ApiGetFolderDetailV3Request {
	r.xTenantId = &xTenantId
	return r
}

// 文件夹 ID 集合，使用逗号分隔，最多查询100个
func (r ApiGetFolderDetailV3Request) CollectionIds(collectionIds string) ApiGetFolderDetailV3Request {
	r.collectionIds = &collectionIds
	return r
}

func (r ApiGetFolderDetailV3Request) Execute() (*GetFolderDetailV3Response, *http.Response, error) {
	return r.ApiService.GetFolderDetailV3Execute(r)
}

/*
GetFolderDetailV3 获取文件夹详情

获取文件夹详情

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFolderDetailV3Request

  @link https://open.teambition.com/docs/apis/64db2903912d20d3b5bb021f document
*/
func (a *FileAPIService) GetFolderDetailV3(ctx context.Context) ApiGetFolderDetailV3Request {
	return ApiGetFolderDetailV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetFolderDetailV3Response
func (a *FileAPIService) GetFolderDetailV3Execute(r ApiGetFolderDetailV3Request) (*GetFolderDetailV3Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetFolderDetailV3Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/collection/query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.collectionIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "collectionIds", r.collectionIds, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xOperatorId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-operator-id", r.xOperatorId, "")
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListFilesV3Request struct {
	ctx context.Context
	ApiService *FileAPIService
	xTenantId *string
	parentId *string
	displayPrefixPath *bool
	projectId *string
	pageSize *int32
	pageToken *string
}

// 企业 ID
func (r ApiListFilesV3Request) XTenantId(xTenantId string) ApiListFilesV3Request {
	r.xTenantId = &xTenantId
	return r
}

// 文件夹ID
func (r ApiListFilesV3Request) ParentId(parentId string) ApiListFilesV3Request {
	r.parentId = &parentId
	return r
}

// 是否显示文件路径
func (r ApiListFilesV3Request) DisplayPrefixPath(displayPrefixPath bool) ApiListFilesV3Request {
	r.displayPrefixPath = &displayPrefixPath
	return r
}

// 项目ID
func (r ApiListFilesV3Request) ProjectId(projectId string) ApiListFilesV3Request {
	r.projectId = &projectId
	return r
}

// 每页任务数量（默认为50）
func (r ApiListFilesV3Request) PageSize(pageSize int32) ApiListFilesV3Request {
	r.pageSize = &pageSize
	return r
}

// 分页标
func (r ApiListFilesV3Request) PageToken(pageToken string) ApiListFilesV3Request {
	r.pageToken = &pageToken
	return r
}

func (r ApiListFilesV3Request) Execute() (*ListFilesV3Response, *http.Response, error) {
	return r.ApiService.ListFilesV3Execute(r)
}

/*
ListFilesV3 获取文件列表

获取文件列表

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListFilesV3Request

  @link https://open.teambition.com/docs/apis/6411504e912d20d3b56ec5ff document
*/
func (a *FileAPIService) ListFilesV3(ctx context.Context) ApiListFilesV3Request {
	return ApiListFilesV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListFilesV3Response
func (a *FileAPIService) ListFilesV3Execute(r ApiListFilesV3Request) (*ListFilesV3Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListFilesV3Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/work/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentId", r.parentId, "")
	}
	if r.displayPrefixPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "displayPrefixPath", r.displayPrefixPath, "")
	}
	if r.projectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "projectId", r.projectId, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.pageToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageToken", r.pageToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoveFileV3Request struct {
	ctx context.Context
	ApiService *FileAPIService
	workId string
	xOperatorId *string
	xTenantId *string
	moveFileV3Request *MoveFileV3Request
}

// 操作者ID
func (r ApiMoveFileV3Request) XOperatorId(xOperatorId string) ApiMoveFileV3Request {
	r.xOperatorId = &xOperatorId
	return r
}

// 企业 ID
func (r ApiMoveFileV3Request) XTenantId(xTenantId string) ApiMoveFileV3Request {
	r.xTenantId = &xTenantId
	return r
}

// 
func (r ApiMoveFileV3Request) MoveFileV3Request(moveFileV3Request MoveFileV3Request) ApiMoveFileV3Request {
	r.moveFileV3Request = &moveFileV3Request
	return r
}

func (r ApiMoveFileV3Request) Execute() (*MoveFileV3Response, *http.Response, error) {
	return r.ApiService.MoveFileV3Execute(r)
}

/*
MoveFileV3 项目内移动文件

项目内移动文件

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workId 文件 ID
 @return ApiMoveFileV3Request

  @link https://open.teambition.com/docs/apis/64db2930912d20d3b5bb7d96 document
*/
func (a *FileAPIService) MoveFileV3(ctx context.Context, workId string) ApiMoveFileV3Request {
	return ApiMoveFileV3Request{
		ApiService: a,
		ctx: ctx,
		workId: workId,
	}
}

// Execute executes the request
//  @return MoveFileV3Response
func (a *FileAPIService) MoveFileV3Execute(r ApiMoveFileV3Request) (*MoveFileV3Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MoveFileV3Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/work/{workId}/parent"
	localVarPath = strings.Replace(localVarPath, "{"+"workId"+"}", url.PathEscape(parameterValueToString(r.workId, "workId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xOperatorId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-operator-id", r.xOperatorId, "")
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	// body params
	localVarPostBody = r.moveFileV3Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoveFolderV3Request struct {
	ctx context.Context
	ApiService *FileAPIService
	collectionId string
	xOperatorId *string
	xTenantId *string
	moveFolderV3Request *MoveFolderV3Request
}

// 操作者ID
func (r ApiMoveFolderV3Request) XOperatorId(xOperatorId string) ApiMoveFolderV3Request {
	r.xOperatorId = &xOperatorId
	return r
}

// 企业 ID
func (r ApiMoveFolderV3Request) XTenantId(xTenantId string) ApiMoveFolderV3Request {
	r.xTenantId = &xTenantId
	return r
}

// 
func (r ApiMoveFolderV3Request) MoveFolderV3Request(moveFolderV3Request MoveFolderV3Request) ApiMoveFolderV3Request {
	r.moveFolderV3Request = &moveFolderV3Request
	return r
}

func (r ApiMoveFolderV3Request) Execute() (*MoveFolderV3Response, *http.Response, error) {
	return r.ApiService.MoveFolderV3Execute(r)
}

/*
MoveFolderV3 移动文件夹

移动文件夹

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param collectionId 文件夹 ID
 @return ApiMoveFolderV3Request

  @link https://open.teambition.com/docs/apis/64db2903912d20d3b5bb00c9 document
*/
func (a *FileAPIService) MoveFolderV3(ctx context.Context, collectionId string) ApiMoveFolderV3Request {
	return ApiMoveFolderV3Request{
		ApiService: a,
		ctx: ctx,
		collectionId: collectionId,
	}
}

// Execute executes the request
//  @return MoveFolderV3Response
func (a *FileAPIService) MoveFolderV3Execute(r ApiMoveFolderV3Request) (*MoveFolderV3Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MoveFolderV3Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/collection/{collectionId}/parent"
	localVarPath = strings.Replace(localVarPath, "{"+"collectionId"+"}", url.PathEscape(parameterValueToString(r.collectionId, "collectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xOperatorId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-operator-id", r.xOperatorId, "")
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	// body params
	localVarPostBody = r.moveFolderV3Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchFilesV3Request struct {
	ctx context.Context
	ApiService *FileAPIService
	xTenantId *string
	q *string
	projectId *string
	pageSize *int32
	pageToken *string
}

// 企业 ID
func (r ApiSearchFilesV3Request) XTenantId(xTenantId string) ApiSearchFilesV3Request {
	r.xTenantId = &xTenantId
	return r
}

// 文件/文件夹名(模糊搜索)
func (r ApiSearchFilesV3Request) Q(q string) ApiSearchFilesV3Request {
	r.q = &q
	return r
}

// 项目ID
func (r ApiSearchFilesV3Request) ProjectId(projectId string) ApiSearchFilesV3Request {
	r.projectId = &projectId
	return r
}

// 每页任务数量（默认为50）
func (r ApiSearchFilesV3Request) PageSize(pageSize int32) ApiSearchFilesV3Request {
	r.pageSize = &pageSize
	return r
}

// 分页标
func (r ApiSearchFilesV3Request) PageToken(pageToken string) ApiSearchFilesV3Request {
	r.pageToken = &pageToken
	return r
}

func (r ApiSearchFilesV3Request) Execute() (*SearchFilesV3Response, *http.Response, error) {
	return r.ApiService.SearchFilesV3Execute(r)
}

/*
SearchFilesV3 搜索文件列表

搜索文件列表

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchFilesV3Request

  @link https://open.teambition.com/docs/apis/68510bf3912d20d3b5cd319e document
*/
func (a *FileAPIService) SearchFilesV3(ctx context.Context) ApiSearchFilesV3Request {
	return ApiSearchFilesV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchFilesV3Response
func (a *FileAPIService) SearchFilesV3Execute(r ApiSearchFilesV3Request) (*SearchFilesV3Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchFilesV3Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/work/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.projectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "projectId", r.projectId, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.pageToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageToken", r.pageToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateFileNameV3Request struct {
	ctx context.Context
	ApiService *FileAPIService
	workId string
	xOperatorId *string
	xTenantId *string
	updateFileNameV3Request *UpdateFileNameV3Request
}

// 操作者ID
func (r ApiUpdateFileNameV3Request) XOperatorId(xOperatorId string) ApiUpdateFileNameV3Request {
	r.xOperatorId = &xOperatorId
	return r
}

// 企业 ID
func (r ApiUpdateFileNameV3Request) XTenantId(xTenantId string) ApiUpdateFileNameV3Request {
	r.xTenantId = &xTenantId
	return r
}

// 
func (r ApiUpdateFileNameV3Request) UpdateFileNameV3Request(updateFileNameV3Request UpdateFileNameV3Request) ApiUpdateFileNameV3Request {
	r.updateFileNameV3Request = &updateFileNameV3Request
	return r
}

func (r ApiUpdateFileNameV3Request) Execute() (*UpdateFileNameV3Response, *http.Response, error) {
	return r.ApiService.UpdateFileNameV3Execute(r)
}

/*
UpdateFileNameV3 更新文件标题

更新文件标题

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workId 文件 ID
 @return ApiUpdateFileNameV3Request

  @link https://open.teambition.com/docs/apis/64db2930912d20d3b5bb7d17 document
*/
func (a *FileAPIService) UpdateFileNameV3(ctx context.Context, workId string) ApiUpdateFileNameV3Request {
	return ApiUpdateFileNameV3Request{
		ApiService: a,
		ctx: ctx,
		workId: workId,
	}
}

// Execute executes the request
//  @return UpdateFileNameV3Response
func (a *FileAPIService) UpdateFileNameV3Execute(r ApiUpdateFileNameV3Request) (*UpdateFileNameV3Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateFileNameV3Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/work/{workId}/name/update"
	localVarPath = strings.Replace(localVarPath, "{"+"workId"+"}", url.PathEscape(parameterValueToString(r.workId, "workId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xOperatorId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-operator-id", r.xOperatorId, "")
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	// body params
	localVarPostBody = r.updateFileNameV3Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateFileVersionV3Request struct {
	ctx context.Context
	ApiService *FileAPIService
	workId string
	xOperatorId *string
	xTenantId *string
	updateFileVersionV3Request *UpdateFileVersionV3Request
}

// 操作者ID
func (r ApiUpdateFileVersionV3Request) XOperatorId(xOperatorId string) ApiUpdateFileVersionV3Request {
	r.xOperatorId = &xOperatorId
	return r
}

// 企业 ID
func (r ApiUpdateFileVersionV3Request) XTenantId(xTenantId string) ApiUpdateFileVersionV3Request {
	r.xTenantId = &xTenantId
	return r
}

// 
func (r ApiUpdateFileVersionV3Request) UpdateFileVersionV3Request(updateFileVersionV3Request UpdateFileVersionV3Request) ApiUpdateFileVersionV3Request {
	r.updateFileVersionV3Request = &updateFileVersionV3Request
	return r
}

func (r ApiUpdateFileVersionV3Request) Execute() (*UpdateFileVersionV3Response, *http.Response, error) {
	return r.ApiService.UpdateFileVersionV3Execute(r)
}

/*
UpdateFileVersionV3 更新文件版本

更新文件版本

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workId 文件 ID
 @return ApiUpdateFileVersionV3Request

  @link https://open.teambition.com/docs/apis/64db2930912d20d3b5bb7e0e document
*/
func (a *FileAPIService) UpdateFileVersionV3(ctx context.Context, workId string) ApiUpdateFileVersionV3Request {
	return ApiUpdateFileVersionV3Request{
		ApiService: a,
		ctx: ctx,
		workId: workId,
	}
}

// Execute executes the request
//  @return UpdateFileVersionV3Response
func (a *FileAPIService) UpdateFileVersionV3Execute(r ApiUpdateFileVersionV3Request) (*UpdateFileVersionV3Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateFileVersionV3Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/work/{workId}/version"
	localVarPath = strings.Replace(localVarPath, "{"+"workId"+"}", url.PathEscape(parameterValueToString(r.workId, "workId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xOperatorId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-operator-id", r.xOperatorId, "")
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	// body params
	localVarPostBody = r.updateFileVersionV3Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateFolderTitleV3Request struct {
	ctx context.Context
	ApiService *FileAPIService
	collectionId string
	xOperatorId *string
	xTenantId *string
	updateFolderTitleV3Request *UpdateFolderTitleV3Request
}

// 操作者ID
func (r ApiUpdateFolderTitleV3Request) XOperatorId(xOperatorId string) ApiUpdateFolderTitleV3Request {
	r.xOperatorId = &xOperatorId
	return r
}

// 企业 ID
func (r ApiUpdateFolderTitleV3Request) XTenantId(xTenantId string) ApiUpdateFolderTitleV3Request {
	r.xTenantId = &xTenantId
	return r
}

// 
func (r ApiUpdateFolderTitleV3Request) UpdateFolderTitleV3Request(updateFolderTitleV3Request UpdateFolderTitleV3Request) ApiUpdateFolderTitleV3Request {
	r.updateFolderTitleV3Request = &updateFolderTitleV3Request
	return r
}

func (r ApiUpdateFolderTitleV3Request) Execute() (*UpdateFolderTitleV3Response, *http.Response, error) {
	return r.ApiService.UpdateFolderTitleV3Execute(r)
}

/*
UpdateFolderTitleV3 更新文件夹标题

更新文件夹标题

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param collectionId 文件夹 ID
 @return ApiUpdateFolderTitleV3Request

  @link https://open.teambition.com/docs/apis/64db2903912d20d3b5bb0173 document
*/
func (a *FileAPIService) UpdateFolderTitleV3(ctx context.Context, collectionId string) ApiUpdateFolderTitleV3Request {
	return ApiUpdateFolderTitleV3Request{
		ApiService: a,
		ctx: ctx,
		collectionId: collectionId,
	}
}

// Execute executes the request
//  @return UpdateFolderTitleV3Response
func (a *FileAPIService) UpdateFolderTitleV3Execute(r ApiUpdateFolderTitleV3Request) (*UpdateFolderTitleV3Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateFolderTitleV3Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/collection/{collectionId}/title/update"
	localVarPath = strings.Replace(localVarPath, "{"+"collectionId"+"}", url.PathEscape(parameterValueToString(r.collectionId, "collectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xOperatorId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-operator-id", r.xOperatorId, "")
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	// body params
	localVarPostBody = r.updateFolderTitleV3Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateFolderVisibilityRequest struct {
	ctx context.Context
	ApiService *FileAPIService
	xOperatorId *string
	xTenantId *string
	collectionId *string
	updateFolderVisibilityRequest *UpdateFolderVisibilityRequest
}

// 操作者ID
func (r ApiUpdateFolderVisibilityRequest) XOperatorId(xOperatorId string) ApiUpdateFolderVisibilityRequest {
	r.xOperatorId = &xOperatorId
	return r
}

// 企业 ID
func (r ApiUpdateFolderVisibilityRequest) XTenantId(xTenantId string) ApiUpdateFolderVisibilityRequest {
	r.xTenantId = &xTenantId
	return r
}

// 文件夹ID
func (r ApiUpdateFolderVisibilityRequest) CollectionId(collectionId string) ApiUpdateFolderVisibilityRequest {
	r.collectionId = &collectionId
	return r
}

// 
func (r ApiUpdateFolderVisibilityRequest) UpdateFolderVisibilityRequest(updateFolderVisibilityRequest UpdateFolderVisibilityRequest) ApiUpdateFolderVisibilityRequest {
	r.updateFolderVisibilityRequest = &updateFolderVisibilityRequest
	return r
}

func (r ApiUpdateFolderVisibilityRequest) Execute() (*UpdateFolderVisibilityResponse, *http.Response, error) {
	return r.ApiService.UpdateFolderVisibilityExecute(r)
}

/*
UpdateFolderVisibility 更新文件夹可见性

更新文件夹可见性

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateFolderVisibilityRequest

  @link https://open.teambition.com/docs/apis/676bb6ff912d20d3b56b8d0f document
*/
func (a *FileAPIService) UpdateFolderVisibility(ctx context.Context) ApiUpdateFolderVisibilityRequest {
	return ApiUpdateFolderVisibilityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateFolderVisibilityResponse
func (a *FileAPIService) UpdateFolderVisibilityExecute(r ApiUpdateFolderVisibilityRequest) (*UpdateFolderVisibilityResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateFolderVisibilityResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/collection/visible/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.collectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xOperatorId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-operator-id", r.xOperatorId, "")
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	// body params
	localVarPostBody = r.updateFolderVisibilityRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
