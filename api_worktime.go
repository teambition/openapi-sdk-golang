/*
Teambition Open API

Teambition Open API

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// WorktimeAPIService WorktimeAPI service
type WorktimeAPIService service

type ApiAggregateUserPlanTimeRequest struct {
	ctx context.Context
	ApiService *WorktimeAPIService
	xTenantId *string
	aggregateUserPlanTimeRequest *AggregateUserPlanTimeRequest
}

// 企业 ID
func (r ApiAggregateUserPlanTimeRequest) XTenantId(xTenantId string) ApiAggregateUserPlanTimeRequest {
	r.xTenantId = &xTenantId
	return r
}

// 
func (r ApiAggregateUserPlanTimeRequest) AggregateUserPlanTimeRequest(aggregateUserPlanTimeRequest AggregateUserPlanTimeRequest) ApiAggregateUserPlanTimeRequest {
	r.aggregateUserPlanTimeRequest = &aggregateUserPlanTimeRequest
	return r
}

func (r ApiAggregateUserPlanTimeRequest) Execute() (*AggregateUserPlanTimeResponse, *http.Response, error) {
	return r.ApiService.AggregateUserPlanTimeExecute(r)
}

/*
AggregateUserPlanTime 获取一定时间内订阅的指定用户的计划工时聚合数

该接口用于查询一定时间内指定用户的计划工时聚合数

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAggregateUserPlanTimeRequest

  @link https://open.teambition.com/docs/apis/6321c6cf912d20d3b5a4901c document
*/
func (a *WorktimeAPIService) AggregateUserPlanTime(ctx context.Context) ApiAggregateUserPlanTimeRequest {
	return ApiAggregateUserPlanTimeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AggregateUserPlanTimeResponse
func (a *WorktimeAPIService) AggregateUserPlanTimeExecute(r ApiAggregateUserPlanTimeRequest) (*AggregateUserPlanTimeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AggregateUserPlanTimeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plantime/aggregation/datesUsers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	// body params
	localVarPostBody = r.aggregateUserPlanTimeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateUserWorkTimeRequest struct {
	ctx context.Context
	ApiService *WorktimeAPIService
	xTenantId *string
	aggregateUserPlanTimeRequest *AggregateUserPlanTimeRequest
}

// 企业 ID
func (r ApiAggregateUserWorkTimeRequest) XTenantId(xTenantId string) ApiAggregateUserWorkTimeRequest {
	r.xTenantId = &xTenantId
	return r
}

// 
func (r ApiAggregateUserWorkTimeRequest) AggregateUserPlanTimeRequest(aggregateUserPlanTimeRequest AggregateUserPlanTimeRequest) ApiAggregateUserWorkTimeRequest {
	r.aggregateUserPlanTimeRequest = &aggregateUserPlanTimeRequest
	return r
}

func (r ApiAggregateUserWorkTimeRequest) Execute() (*AggregateUserWorkTimeResponse, *http.Response, error) {
	return r.ApiService.AggregateUserWorkTimeExecute(r)
}

/*
AggregateUserWorkTime 获取一定时间内订阅的指定用户的实际工时聚合数据

该接口用于查询一定时间内指定用户的实际工时聚合数

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAggregateUserWorkTimeRequest

  @link https://open.teambition.com/docs/apis/6321c6cf912d20d3b5a49110 document
*/
func (a *WorktimeAPIService) AggregateUserWorkTime(ctx context.Context) ApiAggregateUserWorkTimeRequest {
	return ApiAggregateUserWorkTimeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AggregateUserWorkTimeResponse
func (a *WorktimeAPIService) AggregateUserWorkTimeExecute(r ApiAggregateUserWorkTimeRequest) (*AggregateUserWorkTimeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AggregateUserWorkTimeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/worktime/aggregation/datesUsers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	// body params
	localVarPostBody = r.aggregateUserPlanTimeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePlanTimeRequest struct {
	ctx context.Context
	ApiService *WorktimeAPIService
	xTenantId *string
	createPlanTimeRequest *CreatePlanTimeRequest
}

// 企业 ID
func (r ApiCreatePlanTimeRequest) XTenantId(xTenantId string) ApiCreatePlanTimeRequest {
	r.xTenantId = &xTenantId
	return r
}

// 
func (r ApiCreatePlanTimeRequest) CreatePlanTimeRequest(createPlanTimeRequest CreatePlanTimeRequest) ApiCreatePlanTimeRequest {
	r.createPlanTimeRequest = &createPlanTimeRequest
	return r
}

func (r ApiCreatePlanTimeRequest) Execute() (*CreatePlanTimeResponse, *http.Response, error) {
	return r.ApiService.CreatePlanTimeExecute(r)
}

/*
CreatePlanTime 创建计划工时

本接口可用于创建计划工时

注意： 项目归档或回收站 是不能填报工时的，接口会报 「项目已被归档，无法更新工时」或 「项目已在回收站，无法更新工时」错误。

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreatePlanTimeRequest

  @link https://open.teambition.com/docs/apis/6321c6cf912d20d3b5a48f2c document
*/
func (a *WorktimeAPIService) CreatePlanTime(ctx context.Context) ApiCreatePlanTimeRequest {
	return ApiCreatePlanTimeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreatePlanTimeResponse
func (a *WorktimeAPIService) CreatePlanTimeExecute(r ApiCreatePlanTimeRequest) (*CreatePlanTimeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatePlanTimeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plantime/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	// body params
	localVarPostBody = r.createPlanTimeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateWorkTimeRequest struct {
	ctx context.Context
	ApiService *WorktimeAPIService
	xTenantId *string
	createWorkTimeRequest *CreateWorkTimeRequest
}

// 企业 ID
func (r ApiCreateWorkTimeRequest) XTenantId(xTenantId string) ApiCreateWorkTimeRequest {
	r.xTenantId = &xTenantId
	return r
}

// 
func (r ApiCreateWorkTimeRequest) CreateWorkTimeRequest(createWorkTimeRequest CreateWorkTimeRequest) ApiCreateWorkTimeRequest {
	r.createWorkTimeRequest = &createWorkTimeRequest
	return r
}

func (r ApiCreateWorkTimeRequest) Execute() (*CreateWorkTimeResponse, *http.Response, error) {
	return r.ApiService.CreateWorkTimeExecute(r)
}

/*
CreateWorkTime 创建实际工时

该接口用于创建实际工时

注意：
项目归档或回收站 是不能填报工时的，接口会报 「项目已被归档，无法更新工时」或 「项目已在回收站，无法更新工时」错误。

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateWorkTimeRequest

  @link https://open.teambition.com/docs/apis/6321c6cf912d20d3b5a49058 document
*/
func (a *WorktimeAPIService) CreateWorkTime(ctx context.Context) ApiCreateWorkTimeRequest {
	return ApiCreateWorkTimeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateWorkTimeResponse
func (a *WorktimeAPIService) CreateWorkTimeExecute(r ApiCreateWorkTimeRequest) (*CreateWorkTimeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateWorkTimeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/worktime/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	// body params
	localVarPostBody = r.createWorkTimeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateWorkTimeApprovalRequest struct {
	ctx context.Context
	ApiService *WorktimeAPIService
	xTenantId *string
	xOperatorId *string
	createWorkTimeApprovalRequest *CreateWorkTimeApprovalRequest
}

// 企业 ID
func (r ApiCreateWorkTimeApprovalRequest) XTenantId(xTenantId string) ApiCreateWorkTimeApprovalRequest {
	r.xTenantId = &xTenantId
	return r
}

// 创建者 ID
func (r ApiCreateWorkTimeApprovalRequest) XOperatorId(xOperatorId string) ApiCreateWorkTimeApprovalRequest {
	r.xOperatorId = &xOperatorId
	return r
}

// 
func (r ApiCreateWorkTimeApprovalRequest) CreateWorkTimeApprovalRequest(createWorkTimeApprovalRequest CreateWorkTimeApprovalRequest) ApiCreateWorkTimeApprovalRequest {
	r.createWorkTimeApprovalRequest = &createWorkTimeApprovalRequest
	return r
}

func (r ApiCreateWorkTimeApprovalRequest) Execute() (*CreateWorkTimeApprovalResponse, *http.Response, error) {
	return r.ApiService.CreateWorkTimeApprovalExecute(r)
}

/*
CreateWorkTimeApproval 创建实际工时审批对象



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateWorkTimeApprovalRequest

  @link https://open.teambition.com/docs/apis/64337954e66e7e002b322169 document
*/
func (a *WorktimeAPIService) CreateWorkTimeApproval(ctx context.Context) ApiCreateWorkTimeApprovalRequest {
	return ApiCreateWorkTimeApprovalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateWorkTimeApprovalResponse
func (a *WorktimeAPIService) CreateWorkTimeApprovalExecute(r ApiCreateWorkTimeApprovalRequest) (*CreateWorkTimeApprovalResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateWorkTimeApprovalResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/worktime/approve/submit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	if r.xOperatorId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Operator-Id", r.xOperatorId, "")
	}
	// body params
	localVarPostBody = r.createWorkTimeApprovalRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletePlanTimeRequest struct {
	ctx context.Context
	ApiService *WorktimeAPIService
	plantimeId string
	xTenantId *string
	xOperatorId *string
	deletePlanTimeRequest *DeletePlanTimeRequest
}

// 租户 ID
func (r ApiDeletePlanTimeRequest) XTenantId(xTenantId string) ApiDeletePlanTimeRequest {
	r.xTenantId = &xTenantId
	return r
}

// 操作人id
func (r ApiDeletePlanTimeRequest) XOperatorId(xOperatorId string) ApiDeletePlanTimeRequest {
	r.xOperatorId = &xOperatorId
	return r
}

// 
func (r ApiDeletePlanTimeRequest) DeletePlanTimeRequest(deletePlanTimeRequest DeletePlanTimeRequest) ApiDeletePlanTimeRequest {
	r.deletePlanTimeRequest = &deletePlanTimeRequest
	return r
}

func (r ApiDeletePlanTimeRequest) Execute() (*DeletePlanTimeResponse, *http.Response, error) {
	return r.ApiService.DeletePlanTimeExecute(r)
}

/*
DeletePlanTime 删除计划工时单条记录

该接口用于删除指定的单条计划工时记录

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plantimeId 
 @return ApiDeletePlanTimeRequest

  @link https://open.teambition.com/docs/apis/640d7cfa7b2cae002b71a567 document
*/
func (a *WorktimeAPIService) DeletePlanTime(ctx context.Context, plantimeId string) ApiDeletePlanTimeRequest {
	return ApiDeletePlanTimeRequest{
		ApiService: a,
		ctx: ctx,
		plantimeId: plantimeId,
	}
}

// Execute executes the request
//  @return DeletePlanTimeResponse
func (a *WorktimeAPIService) DeletePlanTimeExecute(r ApiDeletePlanTimeRequest) (*DeletePlanTimeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeletePlanTimeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plantime/{plantimeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"plantimeId"+"}", url.PathEscape(parameterValueToString(r.plantimeId, "plantimeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	if r.xOperatorId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Operator-Id", r.xOperatorId, "")
	}
	// body params
	localVarPostBody = r.deletePlanTimeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteWorkTimeRequest struct {
	ctx context.Context
	ApiService *WorktimeAPIService
	worktimeId string
	xTenantId *string
	xOperatorId *string
	deletePlanTimeRequest *DeletePlanTimeRequest
}

// 租户 ID
func (r ApiDeleteWorkTimeRequest) XTenantId(xTenantId string) ApiDeleteWorkTimeRequest {
	r.xTenantId = &xTenantId
	return r
}

// 操作人id
func (r ApiDeleteWorkTimeRequest) XOperatorId(xOperatorId string) ApiDeleteWorkTimeRequest {
	r.xOperatorId = &xOperatorId
	return r
}

// 
func (r ApiDeleteWorkTimeRequest) DeletePlanTimeRequest(deletePlanTimeRequest DeletePlanTimeRequest) ApiDeleteWorkTimeRequest {
	r.deletePlanTimeRequest = &deletePlanTimeRequest
	return r
}

func (r ApiDeleteWorkTimeRequest) Execute() (*DeleteWorkTimeResponse, *http.Response, error) {
	return r.ApiService.DeleteWorkTimeExecute(r)
}

/*
DeleteWorkTime 删除实际工时单条记录

该接口用于删除指定的单条实际工时记录

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param worktimeId 
 @return ApiDeleteWorkTimeRequest

  @link https://open.teambition.com/docs/apis/6405ce05b07df7002be7613d document
*/
func (a *WorktimeAPIService) DeleteWorkTime(ctx context.Context, worktimeId string) ApiDeleteWorkTimeRequest {
	return ApiDeleteWorkTimeRequest{
		ApiService: a,
		ctx: ctx,
		worktimeId: worktimeId,
	}
}

// Execute executes the request
//  @return DeleteWorkTimeResponse
func (a *WorktimeAPIService) DeleteWorkTimeExecute(r ApiDeleteWorkTimeRequest) (*DeleteWorkTimeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteWorkTimeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/worktime/{worktimeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"worktimeId"+"}", url.PathEscape(parameterValueToString(r.worktimeId, "worktimeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	if r.xOperatorId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Operator-Id", r.xOperatorId, "")
	}
	// body params
	localVarPostBody = r.deletePlanTimeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPlanTimeDetailRequest struct {
	ctx context.Context
	ApiService *WorktimeAPIService
	plantimeId string
	xTenantId *string
}

// 企业 ID
func (r ApiGetPlanTimeDetailRequest) XTenantId(xTenantId string) ApiGetPlanTimeDetailRequest {
	r.xTenantId = &xTenantId
	return r
}

func (r ApiGetPlanTimeDetailRequest) Execute() (*GetPlanTimeDetailResponse, *http.Response, error) {
	return r.ApiService.GetPlanTimeDetailExecute(r)
}

/*
GetPlanTimeDetail 获取单个计划工时详情

该接口用于根据计划工时 ID 查询计划工时详情

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plantimeId 计划工时 ID
 @return ApiGetPlanTimeDetailRequest

  @link https://open.teambition.com/docs/apis/6321c6cf912d20d3b5a48f72 document
*/
func (a *WorktimeAPIService) GetPlanTimeDetail(ctx context.Context, plantimeId string) ApiGetPlanTimeDetailRequest {
	return ApiGetPlanTimeDetailRequest{
		ApiService: a,
		ctx: ctx,
		plantimeId: plantimeId,
	}
}

// Execute executes the request
//  @return GetPlanTimeDetailResponse
func (a *WorktimeAPIService) GetPlanTimeDetailExecute(r ApiGetPlanTimeDetailRequest) (*GetPlanTimeDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPlanTimeDetailResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plantime/{plantimeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"plantimeId"+"}", url.PathEscape(parameterValueToString(r.plantimeId, "plantimeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWorkTimeDetailRequest struct {
	ctx context.Context
	ApiService *WorktimeAPIService
	worktimeId string
	xTenantId *string
}

// 企业 ID
func (r ApiGetWorkTimeDetailRequest) XTenantId(xTenantId string) ApiGetWorkTimeDetailRequest {
	r.xTenantId = &xTenantId
	return r
}

func (r ApiGetWorkTimeDetailRequest) Execute() (*GetWorkTimeDetailResponse, *http.Response, error) {
	return r.ApiService.GetWorkTimeDetailExecute(r)
}

/*
GetWorkTimeDetail 获取单个实际工时详情

该接口用于根据实际工时 ID 查询实际工时详情

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param worktimeId 实际工时 ID
 @return ApiGetWorkTimeDetailRequest

  @link https://open.teambition.com/docs/apis/6321c6cf912d20d3b5a49082 document
*/
func (a *WorktimeAPIService) GetWorkTimeDetail(ctx context.Context, worktimeId string) ApiGetWorkTimeDetailRequest {
	return ApiGetWorkTimeDetailRequest{
		ApiService: a,
		ctx: ctx,
		worktimeId: worktimeId,
	}
}

// Execute executes the request
//  @return GetWorkTimeDetailResponse
func (a *WorktimeAPIService) GetWorkTimeDetailExecute(r ApiGetWorkTimeDetailRequest) (*GetWorkTimeDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetWorkTimeDetailResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/worktime/{worktimeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"worktimeId"+"}", url.PathEscape(parameterValueToString(r.worktimeId, "worktimeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPlanTimesRequest struct {
	ctx context.Context
	ApiService *WorktimeAPIService
	xTenantId *string
	userId *string
	pageToken *string
	pageSize *string
	startDate *string
	endDate *string
}

// 企业 ID
func (r ApiListPlanTimesRequest) XTenantId(xTenantId string) ApiListPlanTimesRequest {
	r.xTenantId = &xTenantId
	return r
}

// 用户idID集合,使用逗号分隔，最大数据100
func (r ApiListPlanTimesRequest) UserId(userId string) ApiListPlanTimesRequest {
	r.userId = &userId
	return r
}

// 分页标记，第一次请求不填或者空字符串，表示从头开始遍历；分页查询结果还有更多项时返回 nextPageToken，下次遍历可采用该 nextPageToken 入参 pageToken 获取查询结果，示例值：\&quot;cfcb90voe9jct71bqkfg\&quot;
func (r ApiListPlanTimesRequest) PageToken(pageToken string) ApiListPlanTimesRequest {
	r.pageToken = &pageToken
	return r
}

// 分页大小, 示例值：10
func (r ApiListPlanTimesRequest) PageSize(pageSize string) ApiListPlanTimesRequest {
	r.pageSize = &pageSize
	return r
}

// 查询起始时间，格式 “2022-08-01”
func (r ApiListPlanTimesRequest) StartDate(startDate string) ApiListPlanTimesRequest {
	r.startDate = &startDate
	return r
}

// 查询结束时间，格式 “2022-08-01”，与起始时间间隔90天内
func (r ApiListPlanTimesRequest) EndDate(endDate string) ApiListPlanTimesRequest {
	r.endDate = &endDate
	return r
}

func (r ApiListPlanTimesRequest) Execute() (*ListPlanTimesResponse, *http.Response, error) {
	return r.ApiService.ListPlanTimesExecute(r)
}

/*
ListPlanTimes 获取用户所有计划工时详情数据

获取用户所有计划工时详情数据

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListPlanTimesRequest

  @link https://open.teambition.com/docs/apis/6376eefa912d20d3b59cde89 document
*/
func (a *WorktimeAPIService) ListPlanTimes(ctx context.Context) ApiListPlanTimesRequest {
	return ApiListPlanTimesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListPlanTimesResponse
func (a *WorktimeAPIService) ListPlanTimesExecute(r ApiListPlanTimesRequest) (*ListPlanTimesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListPlanTimesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plantime/query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.pageToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageToken", r.pageToken, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTaskPlanTimesRequest struct {
	ctx context.Context
	ApiService *WorktimeAPIService
	taskId string
	xTenantId *string
}

// 企业 ID
func (r ApiListTaskPlanTimesRequest) XTenantId(xTenantId string) ApiListTaskPlanTimesRequest {
	r.xTenantId = &xTenantId
	return r
}

func (r ApiListTaskPlanTimesRequest) Execute() (*ListTaskPlanTimesResponse, *http.Response, error) {
	return r.ApiService.ListTaskPlanTimesExecute(r)
}

/*
ListTaskPlanTimes 获取单个任务的计划工时列表

该接口用于根据任务 ID 查询单个任务的计划工时列表

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId 任务 ID
 @return ApiListTaskPlanTimesRequest

  @link https://open.teambition.com/docs/apis/6321c6cf912d20d3b5a48fa1 document
*/
func (a *WorktimeAPIService) ListTaskPlanTimes(ctx context.Context, taskId string) ApiListTaskPlanTimesRequest {
	return ApiListTaskPlanTimesRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return ListTaskPlanTimesResponse
func (a *WorktimeAPIService) ListTaskPlanTimesExecute(r ApiListTaskPlanTimesRequest) (*ListTaskPlanTimesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListTaskPlanTimesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plantime/list/task/{taskId}"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTaskWorkTimesRequest struct {
	ctx context.Context
	ApiService *WorktimeAPIService
	taskId string
	xTenantId *string
}

// 企业 ID
func (r ApiListTaskWorkTimesRequest) XTenantId(xTenantId string) ApiListTaskWorkTimesRequest {
	r.xTenantId = &xTenantId
	return r
}

func (r ApiListTaskWorkTimesRequest) Execute() (*ListTaskWorkTimesResponse, *http.Response, error) {
	return r.ApiService.ListTaskWorkTimesExecute(r)
}

/*
ListTaskWorkTimes 获取单个任务的实际工时列表

该接口用于根据任务 ID 查询单个任务的实际工时列表

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId 任务 ID
 @return ApiListTaskWorkTimesRequest

  @link https://open.teambition.com/docs/apis/6321c6cf912d20d3b5a490b3 document
*/
func (a *WorktimeAPIService) ListTaskWorkTimes(ctx context.Context, taskId string) ApiListTaskWorkTimesRequest {
	return ApiListTaskWorkTimesRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return ListTaskWorkTimesResponse
func (a *WorktimeAPIService) ListTaskWorkTimesExecute(r ApiListTaskWorkTimesRequest) (*ListTaskWorkTimesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListTaskWorkTimesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/worktime/list/task/{taskId}"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListWorkTimesRequest struct {
	ctx context.Context
	ApiService *WorktimeAPIService
	xTenantId *string
	userId *string
	pageToken *string
	pageSize *string
	startDate *string
	endDate *string
}

// 企业 ID
func (r ApiListWorkTimesRequest) XTenantId(xTenantId string) ApiListWorkTimesRequest {
	r.xTenantId = &xTenantId
	return r
}

// 用户idID集合,使用逗号分隔，最大数据为100
func (r ApiListWorkTimesRequest) UserId(userId string) ApiListWorkTimesRequest {
	r.userId = &userId
	return r
}

// 分页标记，第一次请求不填或者空字符串，表示从头开始遍历；分页查询结果还有更多项时返回 nextPageToken，下次遍历可采用该 nextPageToken 入参 pageToken 获取查询结果，示例值：\&quot;cfcb90voe9jct71bqkfg\&quot;
func (r ApiListWorkTimesRequest) PageToken(pageToken string) ApiListWorkTimesRequest {
	r.pageToken = &pageToken
	return r
}

// 分页大小, 示例值：10
func (r ApiListWorkTimesRequest) PageSize(pageSize string) ApiListWorkTimesRequest {
	r.pageSize = &pageSize
	return r
}

// 查询起始时间，格式 “2022-08-01”
func (r ApiListWorkTimesRequest) StartDate(startDate string) ApiListWorkTimesRequest {
	r.startDate = &startDate
	return r
}

// 查询结束时间，格式 “2022-08-01”，与起始时间间隔90天内
func (r ApiListWorkTimesRequest) EndDate(endDate string) ApiListWorkTimesRequest {
	r.endDate = &endDate
	return r
}

func (r ApiListWorkTimesRequest) Execute() (*ListWorkTimesResponse, *http.Response, error) {
	return r.ApiService.ListWorkTimesExecute(r)
}

/*
ListWorkTimes 获取用户所有实际工时详情数据

获取用户所有实际工时详情数据。（含回收站任务）

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListWorkTimesRequest

  @link https://open.teambition.com/docs/apis/6376eefa912d20d3b59cdeee document
*/
func (a *WorktimeAPIService) ListWorkTimes(ctx context.Context) ApiListWorkTimesRequest {
	return ApiListWorkTimesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListWorkTimesResponse
func (a *WorktimeAPIService) ListWorkTimesExecute(r ApiListWorkTimesRequest) (*ListWorkTimesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListWorkTimesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/worktime/query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.pageToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageToken", r.pageToken, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSumTaskPlanTimeRequest struct {
	ctx context.Context
	ApiService *WorktimeAPIService
	taskId string
	xTenantId *string
}

// 企业 ID
func (r ApiSumTaskPlanTimeRequest) XTenantId(xTenantId string) ApiSumTaskPlanTimeRequest {
	r.xTenantId = &xTenantId
	return r
}

func (r ApiSumTaskPlanTimeRequest) Execute() (*SumTaskPlanTimeResponse, *http.Response, error) {
	return r.ApiService.SumTaskPlanTimeExecute(r)
}

/*
SumTaskPlanTime 获取单个任务的计划工时总和

该接口用于根据任务 ID 查询单个任务的计划工时总和

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId 任务 ID
 @return ApiSumTaskPlanTimeRequest

  @link https://open.teambition.com/docs/apis/6321c6cf912d20d3b5a48fd3 document
*/
func (a *WorktimeAPIService) SumTaskPlanTime(ctx context.Context, taskId string) ApiSumTaskPlanTimeRequest {
	return ApiSumTaskPlanTimeRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return SumTaskPlanTimeResponse
func (a *WorktimeAPIService) SumTaskPlanTimeExecute(r ApiSumTaskPlanTimeRequest) (*SumTaskPlanTimeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SumTaskPlanTimeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plantime/aggregation/task/{taskId}"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSumTaskWorkTimeRequest struct {
	ctx context.Context
	ApiService *WorktimeAPIService
	taskId string
	xTenantId *string
}

// 企业 ID
func (r ApiSumTaskWorkTimeRequest) XTenantId(xTenantId string) ApiSumTaskWorkTimeRequest {
	r.xTenantId = &xTenantId
	return r
}

func (r ApiSumTaskWorkTimeRequest) Execute() (*SumTaskWorkTimeResponse, *http.Response, error) {
	return r.ApiService.SumTaskWorkTimeExecute(r)
}

/*
SumTaskWorkTime 获取单个任务的实际工时总和

该接口用于根据任务 ID 查询单个任务的实际工时总和

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId 任务 ID
 @return ApiSumTaskWorkTimeRequest

  @link https://open.teambition.com/docs/apis/6321c6cf912d20d3b5a490e1 document
*/
func (a *WorktimeAPIService) SumTaskWorkTime(ctx context.Context, taskId string) ApiSumTaskWorkTimeRequest {
	return ApiSumTaskWorkTimeRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return SumTaskWorkTimeResponse
func (a *WorktimeAPIService) SumTaskWorkTimeExecute(r ApiSumTaskWorkTimeRequest) (*SumTaskWorkTimeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SumTaskWorkTimeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/worktime/aggregation/task/{taskId}"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePlanTimeRequest struct {
	ctx context.Context
	ApiService *WorktimeAPIService
	plantimeId string
	xTenantId *string
	xOperatorId *string
	updatePlanTimeRequest *UpdatePlanTimeRequest
}

// 租户 ID
func (r ApiUpdatePlanTimeRequest) XTenantId(xTenantId string) ApiUpdatePlanTimeRequest {
	r.xTenantId = &xTenantId
	return r
}

// 操作人id
func (r ApiUpdatePlanTimeRequest) XOperatorId(xOperatorId string) ApiUpdatePlanTimeRequest {
	r.xOperatorId = &xOperatorId
	return r
}

// 
func (r ApiUpdatePlanTimeRequest) UpdatePlanTimeRequest(updatePlanTimeRequest UpdatePlanTimeRequest) ApiUpdatePlanTimeRequest {
	r.updatePlanTimeRequest = &updatePlanTimeRequest
	return r
}

func (r ApiUpdatePlanTimeRequest) Execute() (*UpdatePlanTimeResponse, *http.Response, error) {
	return r.ApiService.UpdatePlanTimeExecute(r)
}

/*
UpdatePlanTime 更新计划工时单条记录

该接口用于更新指定的单条计划工时记录

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plantimeId 
 @return ApiUpdatePlanTimeRequest

  @link https://open.teambition.com/docs/apis/640593c1bccdde0036d568f9 document
*/
func (a *WorktimeAPIService) UpdatePlanTime(ctx context.Context, plantimeId string) ApiUpdatePlanTimeRequest {
	return ApiUpdatePlanTimeRequest{
		ApiService: a,
		ctx: ctx,
		plantimeId: plantimeId,
	}
}

// Execute executes the request
//  @return UpdatePlanTimeResponse
func (a *WorktimeAPIService) UpdatePlanTimeExecute(r ApiUpdatePlanTimeRequest) (*UpdatePlanTimeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdatePlanTimeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plantime/{plantimeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"plantimeId"+"}", url.PathEscape(parameterValueToString(r.plantimeId, "plantimeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	if r.xOperatorId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Operator-Id", r.xOperatorId, "")
	}
	// body params
	localVarPostBody = r.updatePlanTimeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateWorkTimeRequest struct {
	ctx context.Context
	ApiService *WorktimeAPIService
	worktimeId string
	xTenantId *string
	xOperatorId *string
	updateWorkTimeRequest *UpdateWorkTimeRequest
}

// 租户 ID
func (r ApiUpdateWorkTimeRequest) XTenantId(xTenantId string) ApiUpdateWorkTimeRequest {
	r.xTenantId = &xTenantId
	return r
}

// 操作人id
func (r ApiUpdateWorkTimeRequest) XOperatorId(xOperatorId string) ApiUpdateWorkTimeRequest {
	r.xOperatorId = &xOperatorId
	return r
}

// 
func (r ApiUpdateWorkTimeRequest) UpdateWorkTimeRequest(updateWorkTimeRequest UpdateWorkTimeRequest) ApiUpdateWorkTimeRequest {
	r.updateWorkTimeRequest = &updateWorkTimeRequest
	return r
}

func (r ApiUpdateWorkTimeRequest) Execute() (*UpdateWorkTimeResponse, *http.Response, error) {
	return r.ApiService.UpdateWorkTimeExecute(r)
}

/*
UpdateWorkTime 更新实际工时单条记录

该接口用于更新指定的单条实际工时记录

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param worktimeId 
 @return ApiUpdateWorkTimeRequest

  @link https://open.teambition.com/docs/apis/640594b7b07df7002be69f92 document
*/
func (a *WorktimeAPIService) UpdateWorkTime(ctx context.Context, worktimeId string) ApiUpdateWorkTimeRequest {
	return ApiUpdateWorkTimeRequest{
		ApiService: a,
		ctx: ctx,
		worktimeId: worktimeId,
	}
}

// Execute executes the request
//  @return UpdateWorkTimeResponse
func (a *WorktimeAPIService) UpdateWorkTimeExecute(r ApiUpdateWorkTimeRequest) (*UpdateWorkTimeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateWorkTimeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/worktime/{worktimeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"worktimeId"+"}", url.PathEscape(parameterValueToString(r.worktimeId, "worktimeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	if r.xOperatorId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Operator-Id", r.xOperatorId, "")
	}
	// body params
	localVarPostBody = r.updateWorkTimeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateWorkTimeApprovalRequest struct {
	ctx context.Context
	ApiService *WorktimeAPIService
	openId string
	xTenantId *string
	xOperatorId *string
	updateWorkTimeApprovalRequest *UpdateWorkTimeApprovalRequest
}

// 企业 ID
func (r ApiUpdateWorkTimeApprovalRequest) XTenantId(xTenantId string) ApiUpdateWorkTimeApprovalRequest {
	r.xTenantId = &xTenantId
	return r
}

// 操作人 ID
func (r ApiUpdateWorkTimeApprovalRequest) XOperatorId(xOperatorId string) ApiUpdateWorkTimeApprovalRequest {
	r.xOperatorId = &xOperatorId
	return r
}

// 
func (r ApiUpdateWorkTimeApprovalRequest) UpdateWorkTimeApprovalRequest(updateWorkTimeApprovalRequest UpdateWorkTimeApprovalRequest) ApiUpdateWorkTimeApprovalRequest {
	r.updateWorkTimeApprovalRequest = &updateWorkTimeApprovalRequest
	return r
}

func (r ApiUpdateWorkTimeApprovalRequest) Execute() (*UpdateWorkTimeApprovalResponse, *http.Response, error) {
	return r.ApiService.UpdateWorkTimeApprovalExecute(r)
}

/*
UpdateWorkTimeApproval 更新工时审批对象



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param openId 审批对象ID
 @return ApiUpdateWorkTimeApprovalRequest

  @link https://open.teambition.com/docs/apis/6433c0d2e66e7e002b32b7d3 document
*/
func (a *WorktimeAPIService) UpdateWorkTimeApproval(ctx context.Context, openId string) ApiUpdateWorkTimeApprovalRequest {
	return ApiUpdateWorkTimeApprovalRequest{
		ApiService: a,
		ctx: ctx,
		openId: openId,
	}
}

// Execute executes the request
//  @return UpdateWorkTimeApprovalResponse
func (a *WorktimeAPIService) UpdateWorkTimeApprovalExecute(r ApiUpdateWorkTimeApprovalRequest) (*UpdateWorkTimeApprovalResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateWorkTimeApprovalResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/worktime/approve/{openId}"
	localVarPath = strings.Replace(localVarPath, "{"+"openId"+"}", url.PathEscape(parameterValueToString(r.openId, "openId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	if r.xOperatorId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Operator-Id", r.xOperatorId, "")
	}
	// body params
	localVarPostBody = r.updateWorkTimeApprovalRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateWorkTimeLimitRequest struct {
	ctx context.Context
	ApiService *WorktimeAPIService
	xTenantId *string
	xOperatorId *string
	updateWorkTimeLimitRequest *UpdateWorkTimeLimitRequest
}

// 企业 ID
func (r ApiUpdateWorkTimeLimitRequest) XTenantId(xTenantId string) ApiUpdateWorkTimeLimitRequest {
	r.xTenantId = &xTenantId
	return r
}

// 操作人 ID
func (r ApiUpdateWorkTimeLimitRequest) XOperatorId(xOperatorId string) ApiUpdateWorkTimeLimitRequest {
	r.xOperatorId = &xOperatorId
	return r
}

// 
func (r ApiUpdateWorkTimeLimitRequest) UpdateWorkTimeLimitRequest(updateWorkTimeLimitRequest UpdateWorkTimeLimitRequest) ApiUpdateWorkTimeLimitRequest {
	r.updateWorkTimeLimitRequest = &updateWorkTimeLimitRequest
	return r
}

func (r ApiUpdateWorkTimeLimitRequest) Execute() (*UpdateWorkTimeLimitResponse, *http.Response, error) {
	return r.ApiService.UpdateWorkTimeLimitExecute(r)
}

/*
UpdateWorkTimeLimit 更新工时企业人天的最大填报时间限制



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateWorkTimeLimitRequest

  @link https://open.teambition.com/docs/apis/66166278912d20d3b5b0af37 document
*/
func (a *WorktimeAPIService) UpdateWorkTimeLimit(ctx context.Context) ApiUpdateWorkTimeLimitRequest {
	return ApiUpdateWorkTimeLimitRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateWorkTimeLimitResponse
func (a *WorktimeAPIService) UpdateWorkTimeLimitExecute(r ApiUpdateWorkTimeLimitRequest) (*UpdateWorkTimeLimitResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateWorkTimeLimitResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx)
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/worktime/restriction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant-Id", r.xTenantId, "")
	}
	if r.xOperatorId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Operator-Id", r.xOperatorId, "")
	}
	// body params
	localVarPostBody = r.updateWorkTimeLimitRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
